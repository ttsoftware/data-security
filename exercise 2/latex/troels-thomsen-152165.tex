\documentclass[12pt]{article}
\usepackage[a4paper, hmargin={2.5cm, 2.5cm}, vmargin={2.5cm, 2.5cm}]{geometry}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{tikz}
\usetikzlibrary{positioning,shapes, shadows, arrows, automata}

\usepackage[T1]{fontenc}
\usepackage{inconsolata}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{float}
\usepackage[english]{varioref}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{etoolbox}

\usepackage{fancyhdr}

\setlength\parindent{0pt}
\usepackage[parfill]{parskip}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}
\definecolor{mygray}{rgb}{0.9451,0.9451,0.9451}

\lstset{
  backgroundcolor=\color{mygray},
  basicstyle=\footnotesize\ttfamily,
  mathescape,
  language=Java,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  breaklines=true,
  numbers=left,
  numberstyle=\ttfamily,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
  literate={->}{$\rightarrow$}{2}
           {ε}{$\varepsilon$}{1}
}

\linespread{1.3}

\title{
  \vspace{4cm}
  \begin{flushleft}
  \Large{\textbf{Excercise 2 - Java Authentication}} \\
  \large{Data Security} \\
  \end{flushleft}
  \vspace{0cm}
  \begin{flushleft}
  \small
  \textit{\today}
  \end{flushleft}
  \vspace{12cm}
  \begin{flushleft}
  \small
  By Troels Thomsen \texttt{152165}\\
  Discussed with Rasmus Haarslev \texttt{152175}
  \end{flushleft}
}

\date{
	%
}

\begin{document}

\clearpage
\pagenumbering{gobble}
\thispagestyle{empty}
\maketitle

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}
\label{sec:Introduction (1 page)}

\textit{The introduction should provide a general introduction to the problem of authentication in client/server applications. It should define the scope of the answer, i.e. explicitly state what problems are considered, and outline the proposed solution. Finally, it should clearly state which of the identified goals are met by the developed software.}

The problem of authentication between server and client is one which is still being solve with many open solutions. The problem lies in the fact that the client needs to authenticate the server, and the server needs to authenticate the client in order to prevent man-in-the-middle attacks. For systems which require a user to sign in with a key, usually in the form of a password, the most common approach to solving the problem is adding an encryption layer on top of the key authentication.

This encryption layer, usually Transport Layer Security (TLS) or its predecessor Secure Sockets Layer (SSL), ensures privacy by encrypting data with a symmetric key which is agreed upon at the beginning of the sessions. This also ensures authenticity of the server, since the servers public key certificate is used to ensure its authenticity. In the ideal scenario the client will also share its public key certificate with the server, allowing the server to validate the authenticity of the client, however in the real world this is not practical since very few people have a personal private / public key pair. This is also the reason why most systemts have the added login with a username and password in the first place, since they cannot authenticate the users otherwise.

Given that anyone can establish a secure connection with the server puts a great deal of pressure on the servers ability to secure its stored user credentials, since they solely act a the sole method of user authentication and are practically the users private keys. Secure storage of passwords remains an industry-wide problem, with many services having exposed their users passwords to attackers in some way or another in recent years.

In the given scenario we need to authenticate a user with a printing service, allowing them to print files to networked printers controlled by the service. The proposed solution will try to solve the problem of authenticating users while securely storing their credentials. It will try to achieve this by storing the passwords in a hashed form using the SHA-512\footnote{\url{https://en.wikipedia.org/wiki/SHA-2}} hashing algorithm with a random 64-bit salt and 10000 hashing rounds.

The solution will assume that all users already exist in the system.
The solution does not try to solve the problem of securely transporting user credentials from the client to the server, and therefore expects the network to be secure.

\newpage

\section{Authentication (3 pages)}
\label{sec:Authentication}

\textit{This section should provide a short introduction to the specific problem of password based authentication in client/server systems and analyse the problems relating to password storage (on the server), password transport (between client and server) and password verification.}

\subsection{Password transport}
\label{sub:Password transport}

\textit{An analysis of the password transport problem must include a discussion of how to implement both individual request authentication and authenticated sessions, where the initial authentication is used to define an authenticated session (e.g. a channel in BAN-logic) that implicitly authenticates messages exchanged. If authentication of invocation requires transfer of any additional parameters between client and server, these should simply be added to the interface defined above.}

When relying on a password-based authentication scheme, the system must take into account the problem of securely transporting the users passwords. The system must work under the assumption that the users are connecting through an insecure network. Given this assumption it is vital that the system can utilize a secure protocol for engaging in encryption of the users authentication request. This means that before the users can authenticate with the system, they must agree upon some sort of encryption scheme.

When establishing a private session without any previously shared secret, we must first verify the origin of system with which the user is communicating. This is done by letting the server share a certificate which has been signed by one or more trusted third parties.
After the initial verification of the server the two parties must agree upon a cipher an a key. There are many ways the parties might go about this.
They could rely on a trusted third party to provide encryption keys given that both parties can securely communicate with this third party. This is a viable option but it does put a great deal of risk on the third party not being compromised, and it limits the possible users of the system to users who have knowledge of the trusted third party.

The parties could have a previously shared key, but we will not consider this case further since it is only useful in a limited set of scenarios.

The parties could also perform a variant of the Diffie–Hellman key exchange protocol, preferably one which authenticates the server and ensures forward secrecy like the Elliptic curve Diffie–Hellman protocol.\footnote{\url{https://en.wikipedia.org/wiki/Elliptic_curve_Diffie-Hellman}}

\subsection{Password storage}
\label{sub:Password storage}

\begin{itemize}
    \item System password file - where the operating system/file system protection mechanisms are used to ensure confidentiality and integrity of the stored data
    \item Public password file - passwords stored in a "public" file, where cryptography is used to ensure confidentiality and integrity of the stored data
    \item Database - passwords stored in a data base management system, where the protection mechanism provided by the dbms is used to ensure the confidentiality and integrity of the stored data
\end{itemize}

\subsection{Password verification}
\label{sub:Password verification}

\textit{The password verification mechanism depends on the choice of password storage and must be explained in the report}
\newpage

\section{Design and implementation (3 pages)}
\label{sec:Design and implementation}

\textit{A software design for the proposed solution must be presented and explained, i.e. why is this particular design chosen. The implementation of the designed authentication mechanism in the client server application must also be outlined in this section.}

\textit{The password verification mechanism depends on the choice of password storage and must be explained in the report.
For the purpose of this lab, it is acceptable to assume that communication between client and server is ensured by other means. It must, however, be explicitly stated if this assumption is made and the specific guarantees required by the channel (e.g. confidentiality, integrity and/or availability) must be specified}

\subsection{Implementation choices}
\label{sub:Implementation choicesn}


The following implementation makes the assumption that the communication between the client and the server takes place on a secure network, and the implementation will therefore not try to solve the problem secure password transport.

Since the implementation is not going to try to solve the problem of secure password transport, it will instead focus on solving the problem of secure user authentication and password storage.

As a mechanism for storing user passwords we have chosen to use a SQL database, however we do not rely on the database's built-in password hashing. This is partly due to the fact that we have chosen a very simple setup with SQLite which do not have built-in functionality for hashing passwords like MySQL's \texttt{PASSWORD()} function. This has the added benefit of making the implementation portable between a virtually all SQL implementations with JDBC driver support. Another added benefit is that the developer of this implementation can make the choice of how they want the passwords to hashed since \texttt{java.security.MessageDigest} supports several cryptographic hashing functions, and the developer can further choose the salts and the number of hashing iterations used.

The reason we chose to use a database for password storage over a system file or a public password file is again portability. The solution can easily be ported to other systems since it does not rely on operating-system or file-system specific functionality. Using a database has the added benefit of relieving the developer from worrying about efficient file-system usage and similar issues which might arise if one were to try to implement a password file mechanism for storing passwords.

\subsection{Password hashing}
\label{sub:Password hashing}

The solution re-purposes the implementation of SHA-2 hashing with salts with the use of the \texttt{java.security} package found at \url{https://www.owasp.org/index.php/Hashing_Java}.

By default, unless a different salt is specified, the implementation generates a random 64-bit salt and uses it on a 512-bit SHA-2 digest. The clear text password is then hashed using the generated digest in 10000 iterations of re-hashing.
In order to be able to authenticate the user we need to store both the hash and the randomly generated salt.

We add the 64-bit salt in order to try to avoid having any to passwords hash to the same 512-bit value, and thus avoid attacks exploiting the birthday paradox.

By hashing over 10000 iterations we force any attacker to spend a factor of 10000 longer time when trying to break the hash. This adds to the time-cost for the system when generating hashes, but compared to the extra time added to the attackers procedure, the added iterations yields a good trade-off.

\begin{figure}[h!]
    \begin{lstlisting}
public Pair<String, String> hash(String password) throws UnsupportedEncodingException, NoSuchAlgorithmException {
    // Salt generation 64 bits long
    byte[] salt = new byte[8];
    new Random().nextBytes(salt);
    return hash(password, salt);
}

public Pair<String, String> hash(String password, byte[] salt) throws NoSuchAlgorithmException, UnsupportedEncodingException {
    MessageDigest digest = MessageDigest.getInstance("SHA-512");
    digest.reset();
    digest.update(salt);
    byte[] digestedPassword = digest.digest(password.getBytes("UTF-8"));

    for (int i = 0; i < ITERATION_NUMBER; i++) {
        digest.reset();
        digestedPassword = digest.digest(digestedPassword);
    }

    // Returns the hashed password and the salt
    return new Pair<String, String>(byteToBase64(digestedPassword), byteToBase64(salt));
}
    \end{lstlisting}
    \caption{The code which generates the 512-bit SHA-2 hash.}
\end{figure}

My implementation is based on the following understanding of the problem.

\begin{enumerate}
    \item Implement a RMI server, exposing the interface shown in Appendix~\ref{appendix:service-interface} to the client.
    \item Authenticate users on the server before allowing them to use the RMI service.
    \begin{itemize}
        \item The server assumes users already exist and do not handle creation of new users.
        \item The implementation of this authentication should include a secure user password storage.
    \end{itemize}
\end{enumerate}


\newpage

\section{Evaluation (2 pages)}
\label{sec:Evaluation}

\textit{This section should document that the requirements defined in Section 2 have been satified by the implementation. In particular, the evaluation should demonstrate that the user is always authenticated by the server before the service is invoked, e.g. the username and methodname may be written to a logfile every time a service is invoked.
The evaluation should provide a simple summary of which of the requirements are satisfied and which are not.}

\newpage

\section{Conclusion (1 page)}
\label{sec:Conclusion}

\textit{The conclusions should summarize the problems addressed in the report and clearly identify which of the requirements are satisfied and which are not (a summary of Section 4). The conclusions may also include a brief outline of future work.}

%\newpage
%\appendix

%\section{Code}
%\label{sec:Code}

%\subsection{PrintService.java}
%\label{sub:PrintService.java}

%\lstinputlisting[label={appendix:service-interface}]{../RMI/src/main/java/shared/PrintService.java}

\end{document}
